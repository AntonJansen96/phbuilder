#!/bin/python3
# PYTHON_ARGCOMPLETE_OK

# Execute this as soon as possible because of the TAB autocomplete thing.
from parsecmdline import parsecmdline
CLI = parsecmdline()

# Import the rest of the modules.
import configparser, os
from user import User
from structure import Structure
from mdp import gen_mdp

# Stores the information for a lambda group type.
class LambdaType:
    def __init__(self, groupname, incl, pKa, atoms, qqA, qqB, dvdl):
        self.d_groupname = groupname  # str
        self.d_incl      = incl       # list
        self.d_pKa       = pKa        # list  (previously str)
        self.d_atoms     = atoms      # list
        self.d_qqA       = qqA        # list
        self.d_qqB       = qqB        # list of lists (previously list)
        self.d_dvdl      = dvdl       # list of lists (previously list)

# Main phbuilder object.
class phbuilder(User):
    # Construct phbuilder object (handles input parsed from cmdline).
    def __init__(self, CLI):
        super().__init__(CLI.verbosity)
        
        # Add universal parameters to the universe (used by all three targets).
        self.d_target = CLI.target
        self.d_file   = CLI.file

        # If we run gentopol...
        if (CLI.target == 'gentopol'):
            self.d_output = CLI.output

            # Process whether the -inter flag was or wasn't set.
            if (CLI.inter != None):
                self.ph_inter = True
            else:
                self.ph_inter = False

            # Process whether the -list flag was or wasn't set.
            if (CLI.list != None):
                resid = []
                for line in open(CLI.list).readlines():
                    resid.append(line.split()[0])

                self.ph_list_resid = [int(i) for i in resid]

        # If we run addbuffers...
        elif (CLI.target == 'addbuffers'):
            # Either required or has a default value
            self.d_output  = CLI.output
            self.d_topol   = CLI.topol
            self.d_solname = CLI.solname

            # Optional
            if (CLI.nbufs != None):
                self.ph_nbufs = CLI.nbufs

        # If we run genparams...
        elif (CLI.target == 'genparams'):
            self.d_mdp     = CLI.mdp
            self.d_ndx     = CLI.ndx
            self.ph_ph     = CLI.ph
            self.ph_nstout = CLI.nstout
            self.ph_dwpE   = CLI.dwpE
            self.ph_lmass  = CLI.lmass
            self.ph_ltau   = CLI.ltau

            # Process whether the -inter flag was or wasn't set
            if (CLI.inter != None):
                self.ph_inter = True
            else:
                self.ph_inter = False

        # User information.
        self.verbose("Parsed the following input from the command line:")
        self.verbose(vars(CLI))

        self.parseLambdaGroupTypesFile()

    # Parse lambdagrouptypes.dat
    def parseLambdaGroupTypesFile(self):
        # Initialize some entries
        self.ph_lambdaTypes = []
        self.ph_BUF_dvdl    = None

        # Add a lambda residue-type to universe.
        def defineLambdaType(groupname, incl, pKa, atoms, qqA, qqB, dvdl):

            # Create a temporary LambdaType object.
            NewLambdaType = LambdaType(groupname, incl, pKa, atoms, qqA, qqB, dvdl)

            # Only add NewLambdaType to ph_lambdaTypes if it does not exist yet.
            alreadyPresent = False
            for entry in self.ph_lambdaTypes:
                if entry.d_groupname == NewLambdaType.d_groupname:
                    self.warning("LambdaType with groupname {} is already defined. Skipping...")
                    alreadyPresent = True
                    break

            if not alreadyPresent:
                self.ph_lambdaTypes.append(NewLambdaType)

        # Internal function to convert string to list of floats.
        def str2floatList(string):
            return [float(val) for val in string.split(' ')]

        # Internal function to convert string to list of strings.
        def str2strList(string):
            return string.split(' ')

        # Do the actual parsing
        parser = configparser.ConfigParser()
        parser.read("lambdagrouptypes.dat") # name is hardcoded.

        # Loop through the sections.
        for sect in parser.sections():
            
            # Parse force field parameters
            if (sect.strip() == "FORCEFIELD"):
                self.d_modelFF    = parser.get(sect, 'path')
                self.d_modelwater = parser.get(sect, 'water')
                continue

            # Parse buffer parameters
            if (sect.strip() == "BUF"):
                self.ph_BUF_dvdl  = str2floatList(parser.get(sect, 'dvdl'))
                self.ph_BUF_range = str2floatList(parser.get(sect, 'range'))
                continue

            # Parse groupname
            groupname = sect.strip()[0:4]

            # Parse incl
            incl = str2strList(parser.get(sect, 'incl'))

            # Parse atoms
            atoms = str2strList(parser.get(sect, 'atoms'))

            # Parse qqA
            qqA = str2floatList(parser.get(sect, 'qqA'))

            pKa  = []
            qqB  = []
            dvdl = []
            for idx in range(1, 11): # Max 10 multistates
                try:
                    # Parse pKa(s)
                    pKa.append(parser.get(sect, 'pKA_{}'.format(idx)))

                    # Parse qqB(s)
                    qqB.append(str2floatList(parser.get(sect, 'qqB_{}'.format(idx))))

                    # Parse dvdl(s)
                    dvdl.append(str2floatList(parser.get(sect, 'dvdl_{}'.format(idx))))
                except:
                    break

            # SANITIZE INPUT

            if (len(groupname) < 2 or len(groupname) > 4):
                self.error("groupname of LambdaType needs to contain between 2 and 4 characters.")

            # Call function that constructs the LambdaType object.
            defineLambdaType(groupname, incl, pKa, atoms, qqA, qqB, dvdl)

        # USER UPDATE

        self.verbose("ffpath    = {}".format(self.d_modelFF))
        self.verbose("water     = {}".format(self.d_modelwater))

        for obj in self.ph_lambdaTypes:
            self.verbose("groupname = {}".format(obj.d_groupname))
            self.verbose("incl      = {}".format(obj.d_incl))
            self.verbose("pKa       = {}".format(obj.d_pKa))
            self.verbose("atoms     = {}".format(obj.d_atoms))
            self.verbose("qqA       = {}".format(obj.d_qqA))
            self.verbose("qqB       = {}".format(obj.d_qqB))
            self.verbose("dvdl      = {}\n".format(obj.d_dvdl))

        if (self.ph_BUF_dvdl != None):
            self.verbose("BUF_dvdl  = {}\n".format(self.ph_BUF_dvdl))
        else:
            self.warning("dvdl coefficients for buffer were not found in lambdagrouptypes.dat.")
            self.warning("This is fine if you don't plan on using charge restraining/buffers.")

    # Call correct sub function depending on specified target on cmdline.
    def runner(self):
        if self.d_target == 'gentopol':
            self.update('Running gentopol...')
            self.gentopol()

        elif self.d_target == 'addbuffers':
            self.update('Running addbuffers...')
            self.addbuffers()

        elif self.d_target == 'genparams':
            self.update('Running genparams...')
            self.genparams()

    # Prepare topology.
    def gentopol(self):

        # If the user does not specify the -inter flag, all the residues associated
        # with a lambdagrouptype will by default made titratable. These residues
        # will be put in the lowest charge state (can be changed later.)
        def automaticLambdaInits(qqA, qqB):
            if len(qqB) > 1:    # We can ignore qqA in the multistate case. Instead
                inits = []      # we compile a list  of sums of the qqB states and 
                sums  = []      # set the state with the lowest abs val charge to 1
                for lst in qqB: # and the rest to 0.
                    sums.append(abs(sum(lst)))

                for idx in range(0, len(qqB)):
                    if idx == sums.index(min(sums)):
                        return idx + 1
            # In the 2state case, we simply pick the smallest abs val of the sum,
            # OR if the charges are opposite, the neutral charge will be in the
            # middle, which will then corresponds to lambda = 0.5.
            else:
                sumA = abs(sum(qqA))
                sumB = abs(sum(qqB[0]))
                return int(sumA > sumB)

        # Part I - COPY FORCE FIELD AND RESIDUETYPES.DAT TO WORKING DIR

        tail, head = os.path.split(self.d_modelFF)

        os.system("cp -r {} {}/residuetypes.dat .".format(self.d_modelFF, tail))

        self.verbose('Force field path stuff: ')
        self.verbose('full-path    = {}'.format(self.d_modelFF))
        self.verbose('tail-path    = {}'.format(tail))
        self.verbose('residuetypes = {}/residuetypes.dat'.format(tail))
        self.verbose('head-path    = {}'.format(head))

        # Remove .ff extention from force field.
        self.d_modelFF = os.path.splitext(head)[0]
        self.verbose('ffield name  = {}'.format(self.d_modelFF))

        # PART II - LOAD DATA

        # Load the .pdb/.gro structure (and implictly record.dat, if it exists).
        pdb = Structure(self.d_file, self.d_verbosity)

        # Load user-specified list of residues (if any).
        if hasattr(self, 'ph_list_resid'):
            list_resid = self.ph_list_resid
            
            self.update('Found user-defined list containing residues to consider...')
            self.verbose(list_resid)

        # PART III - LOOP THROUGH THE RESIDUES AND MODIFY

        self.update("Modifying structure file...")

        # Loop through all the residue objects.
        for residue in pdb.d_residues:
            
            # Get the lambdaType object for which d_incl contains residue.d_resname (if any).
            associatedLambdaType = [lambdaType for lambdaType in self.ph_lambdaTypes if residue.d_resname in lambdaType.d_incl]

            # If this list is not empty, i.e. an associated LambdaType was found...
            if associatedLambdaType:

                # Turn this list, containing one object, into the object.
                associatedLambdaType = associatedLambdaType[0]
            
                # If -list was set AND the current residue is not in the list, continue to the next residue.
                if hasattr(self, 'ph_list_resid') and (residue.d_resid not in list_resid):
                    continue

                # Store original name here as we'll need it later for a user update.
                origName = residue.d_resname

                # If -inter was set, ask for every residue individually:
                if self.ph_inter:
                    # List to hold the various options for the user.
                    options = ["Keep current (static) protonation state"]

                    # Is this multistate yes/no? Multistate and 2state need to be treated differently.
                    multistate = len(associatedLambdaType.d_pKa) > 1

                    if multistate:
                        chargeLists = associatedLambdaType.d_qqB
                        for idx in range(0, len(chargeLists)):
                            options.append("Make titratable (rename to {}), start in state {} (q = {:+.2f})".format(associatedLambdaType.d_groupname, idx + 1, sum(chargeLists[idx])))

                        val = self.inputOptionHandler("Choose what to do with residue {}-{} in chain {}".format(residue.d_resname, residue.d_resid, residue.d_chain), options)

                        if val != 0:
                            residue.d_resname = associatedLambdaType.d_groupname
                            residue.d_init = str(val)

                    if not multistate:
                        chargeLists = [associatedLambdaType.d_qqA, associatedLambdaType.d_qqB[0]]
                        for idx in range(0, len(chargeLists)):
                            options.append("Make titratable (rename to {}), start in state {} (q = {:+.2f})".format(associatedLambdaType.d_groupname, idx, sum(chargeLists[idx])))

                        val = self.inputOptionHandler("Choose what to do with residue {}-{} in chain {}".format(residue.d_resname, residue.d_resid, residue.d_chain), options)

                        if val != 0:
                            residue.d_resname = associatedLambdaType.d_groupname
                            residue.d_init = str(val)

                else: # If -inter was not set, just protonate everything automatically.
                    residue.d_resname = associatedLambdaType.d_groupname
                    self.update("Made residue {}-{} in chain {} titratable (changed name to {})".format(origName, residue.d_resid, residue.d_chain, residue.d_resname))

                    # Additionally, use automaticLambdaInits to set the initial lambda values.
                    init = automaticLambdaInits(associatedLambdaType.d_qqA, associatedLambdaType.d_qqB)
                    residue.d_init = str(init)

                continue # Otherwise code below is executed for the same residue we just changed.

            # Get the lambdaType object for which d_groupname = residue.d_resname (if any).
            associatedLambdaType = [lambdaType for lambdaType in self.ph_lambdaTypes if residue.d_resname == lambdaType.d_groupname]

            # If this list is not empty, i.e. an associated LambdaType was found,
            if associatedLambdaType:

                # Turn this list, containing one object, into the object.
                associatedLambdaType = associatedLambdaType[0]

                # If -list was set AND the current residue is not in the list, continue to the next residue.
                if hasattr(self, 'ph_list_resid') and (residue.d_resid not in list_resid):
                    continue

                # If -inter was set, ask for every residue individually:
                if self.ph_inter:
                    
                    # List to hold the various options for the user.
                    options = []
                    
                    # Is this multistate yes/no? Multistate and 2state need to be treated differently.
                    multistate = len(associatedLambdaType.d_pKa) > 1

                    if multistate:
                        chargeLists = associatedLambdaType.d_qqB
                        for idx in range(0, len(chargeLists)):
                            options.append("Keep titratable, start in state {} (q = {:+.2f})".format(idx + 1, sum(chargeLists[idx])))

                    if not multistate:
                        chargeLists = [associatedLambdaType.d_qqA, associatedLambdaType.d_qqB[0]]
                        for idx in range(0, len(chargeLists)):
                            options.append("Keep titratable, start in state {} (q = {:+.2f})".format(idx, sum(chargeLists[idx])))  

                    for name in associatedLambdaType.d_incl:
                        options.append("Change name to {}".format(name))

                    val = self.inputOptionHandler("Choose what to do with residue {}-{} in chain {} in initial state {}".format(residue.d_resname, residue.d_resid, residue.d_chain, residue.d_init), options)

                    # If user picks one of the "still titratable" options:
                    if val in range(0, len(chargeLists)):
                        residue.d_init = str(val)

                    else: # Else the user picked one of the non-titratable options
                        residue.d_resname = associatedLambdaType.d_incl[val - len(chargeLists)]
                        residue.d_init = ' '
                
                # Normally, we would not have to do anything. However, if we are
                else: # missing initial lambda values in the record, we need to add them.
                    init = automaticLambdaInits(associatedLambdaType.d_qqA, associatedLambdaType.d_qqB)
                    residue.d_init = str(init)

            # If the residue in question is neither an ASP nor an ASPT, as an extra
            else: # measure we make sure that nothing is present in the init field.
                residue.d_init = ' '

        # PART IV - HANDLE UNKNOWN RESIDUE TYPES

        self.update("Checking if every residue type is present in residuetypes.dat...")

        # Load residuetypes.dat into list
        residueTypes = []
        for val in open('residuetypes.dat').readlines():
            residueTypes.append(val.split()[0])

        # Compile lists of the unknown residue(s)(types)
        unknownResidues = []
        unknownResTypeNames = []
        for residue in pdb.d_residues:

            if residue.d_resname not in residueTypes:
                unknownResidues.append(residue)

                if residue.d_resname not in unknownResTypeNames:
                    unknownResTypeNames.append(residue.d_resname)

        pathList = []   # Loop through the unknown residue types and add them to 
        skipList = []   # skipList and (the manually specified path to) pathList.
        good = True
        for val in unknownResTypeNames:
            self.warning("residue type {} in {} wasn't found in residuetypes.dat associated with {}".format(val, self.d_file, self.d_modelFF))
            path = input("phbuilder : Please specify path to .itp file (e.g. /path/to/some.itp): ")

            skipList.append(val)
            pathList.append(path)
            good = False

            self.update("Set path for residue type {} to {}...".format(val, path))

        if good:
            self.update("everything seems OK.")
            pdb.write(self.d_output)

        else:
            # Create a list knownResidues containing only the known residues
            knownResidues = []
            for residue in pdb.d_residues:
                if residue.d_resname not in skipList:
                    knownResidues.append(residue)

            # Update d_residues in universe with knownResidues
            pdb.d_residues = knownResidues

            # Write temporary .pdb containing only the known residues
            someTempName = 'pdb2gmxtemp.pdb'
            pdb.write(someTempName)

            # Update value of d_output (so that pdb2gmx is called on the temporary 
            # structure), and backup the final output name as specified by user.
            self.d_output_orig = self.d_output
            self.d_output      = someTempName

        # PART IV - RUN PDB2GMX AND ASK USER FOR INPUT ABOUT IT 

        self.update("\nRecommended pdb2gmx command:")
        self.update("gmx pdb2gmx -f {0} -o {0} -ff {1} -water {2} -ignh".format(self.d_output, self.d_modelFF, self.d_modelwater))

        # Ask for input for what to do regarding pdb2mgx
        val = self.inputOptionHandler(
            "Choose whether to", 
            ["Do nothing", "Run", "Add additional flags (https://manual.gromacs.org/documentation/current/onlinehelp/gmx-pdb2gmx.html)"])

        flags = ""
        if val == 2:
            flags += input("phbuilder : Enter flags: ")

        # Run pdb2gmx:
        if val in [1, 2]:
            self.update("Calling GROMACS ({}/gmx)...\n".format(os.environ.get("GMXBIN")))
            os.system("gmx pdb2gmx -f {0} -o {0} -ff {1} -water {2} -ignh {3}".format(self.d_output, self.d_modelFF, self.d_modelwater, flags))

        # If we do nothing, then return because we do not want to do PART V?
        if val == 0:
            return

        # PART V - MERGE THE .PDB FILES

        # If pathList is not empty, i.e. if we had at least one unknown residue:
        if pathList:
            # Load the structure output of pdb2gmx (update d_residues in universe)
            pdb.read(someTempName)

            # Merge the processed structure of good residues with unknown residues
            mergedResidues = pdb.d_residues + unknownResidues

            # Update d_residues in universe
            pdb.d_residues = mergedResidues

            # Write the final structure
            pdb.write(self.d_output_orig)

        # PART VI - MERGE THE TOPOLOGIES

        # Write manually specified files to topol.top
        def add_mol(itpfname, comment, molname=None, molcount=None):
            # Get the contents of current topol.top.
            topList = []
            with open("topol.top") as file:
                for line in file.readlines():
                    topList.append(line)

            # Add the .itp file (line saying: #include "blabla.itp")
            with open("topol.top", 'w') as file:
                try:
                    for line in range(0, len(topList)):
                        file.write(topList[line])

                        if "[ system ]\n" == topList[line + 1]:
                            file.write("; {0}\n".format(comment))
                            file.write("#include \"{0}\"\n\n".format(itpfname))

                except IndexError:
                    pass

            # if molcount not present, add it, otherwise do nothing.
                if molname != None and molcount != None and molname not in topList[-1]:
                    file.write("{0}\t\t\t{1}\n".format(molname, molcount))

        # If pathList is not empty, i.e. if we had at least one unknown residue:
        if pathList:
            # Remove temporary .pdb file
            os.remove(someTempName)

            # Loop through the unknown residue types
            for idx in range(0, len(skipList)):

                # For each one, count how many there are
                count = 0
                for residue in pdb.d_residues:
                    if residue.d_resname == skipList[idx]:
                        count += 1

                # Add manually to topol.top
                add_mol(pathList[idx], "Include topology for {}".format(skipList[idx]), skipList[idx], count)

        self.update("Finished generating topology for constant-pH.")

    # Add buffers.
    def addbuffers(self):
        maxChargeOnBuffer = 0.3

        # PART I - PREP

        # Load the input structure into d_residues.
        pdb = Structure(self.d_file, self.d_verbosity)

        # Perform some basic checks for PBC box, solvent, and titratable groups.
        foundPBC         = hasattr(pdb, 'd_box')
        foundSolvent     = False
        foundTitratables = False

        LambdaTypeNames = []
        for LambdaType in self.ph_lambdaTypes:
            LambdaTypeNames.append(LambdaType.d_groupname)

        for residue in pdb.d_residues:

            if residue.d_resname == self.d_solname:
                foundSolvent = True

            elif residue.d_resname in LambdaTypeNames:
                foundTitratables = True

            if foundSolvent and foundTitratables:
                break

        # Error if no periodic box was found
        if not foundPBC:
            self.error("{} doesn't have a periodic box! Did you forget to add one?".format(self.d_file))

        # Error if no solvent was found
        if not foundSolvent:
            self.error("{} doesn't seem to have any {} molecules! Did you forget to add solvent?".format(self.d_file, self.d_solname))

        # Warning if no titratable residues were found
        if not foundTitratables:
            self.warning("{} doesn't seem to have any titratable groups! Did you forget to run gentopol?".format(self.d_file))

        # if nbufs wasn't manually set, count the number of titratable residues.
        if not hasattr(self, 'ph_nbufs'):
            # Count number of titratable residues
            titratables = 0
            for residue in pdb.d_residues:
                if residue.d_resname in LambdaTypeNames:
                    titratables += 1

            nbufs = int(titratables / maxChargeOnBuffer) + 1 # Worst case scenario.
            self.update("Counted {0} titratable residues, will add ceil({0}/{1}) = {2} buffer(s)...".format(titratables, maxChargeOnBuffer, nbufs))

        else:
            nbufs = self.ph_nbufs
            self.update("Will add {} buffer(s) (per user request)...".format(nbufs))

        # PART II - RUN GMX GENION TO REPLACE SOLVENT MOLECULES WITH BUFFER

        # Create dummy mdp file for gmx grompp
        open('dummy.mdp', 'w').close()

        # Run gmx grompp to create a .tpr file for gmx genion
        os.system("gmx grompp -f dummy.mdp -c {} -p {} -o dummy.tpr >> builder.log 2>&1".format(self.d_file, self.d_topol))

        # Run gxm genion to replace some solvent molecules with buffers
        os.system("gmx genion -s dummy.tpr -p {} -o {} -pname {} -np {} >> builder.log 2>&1 << EOF\n{}\nEOF".format(
            self.d_topol,
            self.d_output,
            'BUF', 
            nbufs,
            self.d_solname))

        # PART III - WRAPUP

        # Remove dummy files
        os.remove('dummy.tpr'); os.remove('dummy.mdp')

        # Update d_residues in universe
        pdb.read(self.d_output)

        # Check whether the required number of buffers was added
        BUFcount = 0
        for residue in pdb.d_residues:
            if residue.d_resname == 'BUF':
                BUFcount += 1

        if BUFcount == nbufs:
            self.update("Succesfully added {} buffer molecule(s)...".format(BUFcount))
        else:
            self.warning("Only added {}/{} buffer molecules! Try increasing box size...")

    # Generate parameters for MD.mdp.
    def genparams(self):
        # PART I - PREP

        # Load the input structure into d_residues.
        pdb = Structure(self.d_file, self.d_verbosity)

        # List of groupnames of the LambdaTypes specified in lambdagrouptypes.dat.
        LambdaTypeNames = []
        for LambdaType in self.ph_lambdaTypes:
            LambdaTypeNames.append(LambdaType.d_groupname)

        # Check whether we have any titratable residues in the structure, and also
        # check whether we have any buffers.
        anyTitratables = False
        restrainCharge = False

        for residue in pdb.d_residues:
            if residue.d_resname in LambdaTypeNames:
                anyTitratables = True

            elif residue.d_resname == 'BUF':
                restrainCharge = True

            if anyTitratables and restrainCharge:
                break

        if not anyTitratables:
            self.error("No titratable residues detected!")

        if not restrainCharge:
            self.warning("No buffer(s) found. Will not use charge restraining...")

        # If no .mdp file was specified on the command line, generate our default one:
        if self.d_mdp == None:
            self.update('No .mdp file was specified. Creating a default MD.mdp file...')

            val = self.inputOptionHandler("Simulating a membrane protein?", ['No', 'Yes'])

            gen_mdp('MD', 50000, 5000, membrane=val)

            self.d_mdp = 'MD.mdp'

        # If no .ndx file was specified on the command line, generate our default one:
        if self.d_ndx == None:
            self.update('No .ndx file was specified. Creating a default index.ndx file...')
            os.system("gmx make_ndx -f {0} >> builder.log 2>&1 << EOF\nq\nEOF".format(self.d_file))

        file = open(self.d_mdp, 'a')

        # Formatting function for adding parameters.
        def addParam(name, value):
                file.write("{:54s} = {:13s}\n".format(name, str(value)))

        # PART 1 - WRITE GENERAL PARAMETERS

        file.write("\n; CONSTANT PH\n")

        addParam('lambda-dynamics', 'yes')
        addParam('lambda-dynamics-simulation-ph', "{:.1f}".format(self.ph_ph))
        addParam('lambda-dynamics-lambda-particle-mass', "{:.1f}".format(self.ph_lmass))
        addParam('lambda-dynamics-tau', "{:.1f}".format(self.ph_ltau))
        addParam('lambda-dynamics-update-nst', self.ph_nstout)

        # If we use charge restraining...
        if restrainCharge:
            addParam('lambda-dynamics-charge-constraints', 'yes')

        # We need to count how many titratable residues in total we have in the
        # protein. For this we compile a list LambdasFoundinProtein.
        LambdasFoundinProtein = [] # (e.g ASPT ASPT GLUT ASPT GLUT ASPT...)

        # Stores the number of buffer atoms/ions.
        buffersFoundinProtein = 0

        for residue in pdb.d_residues:
            if residue.d_resname in LambdaTypeNames:
                LambdasFoundinProtein.append(residue.d_resname)

            # Also in this loop we count how many buffer ions we have.
            elif restrainCharge and residue.d_resname == 'BUF':
                buffersFoundinProtein += 1

        # The fact that we have a LambdaType in lambdagrouptypes.dat does not mean
        # one of those is also present in the protein. In that case, we want to 
        # prevent counting it, so we compile a subgroup of LambdaType groupnames
        # that are not only in lambdagrouptypes.dat, but ALSO found at least once 
        # in the actual protein.
        LambdaTypeNamesFoundinProtein = list(set(LambdasFoundinProtein)) # (e.g ASPT GLUT)

        # If we not only have multistate LambdaResidueTypes defined in the .dat file,
        # but we also have detected such a LambdaResidueType in the actual protein,
        # we'll need to turn on multistate:
        for LambdaType in self.ph_lambdaTypes:
            if len(LambdaType.d_pKa) > 1 and LambdaType.d_groupname in LambdaTypeNamesFoundinProtein:
                addParam('lambda-dynamics-multistate-constraints', 'yes')

        # If we use charge-restraining we also have he BUF residue-type, as well as 
        # one extra lambda group containing all the BUFs.
        if restrainCharge:
            addParam('lambda-dynamics-number-lambda-group-types', len(LambdaTypeNamesFoundinProtein) + 1)
            addParam('lambda-dynamics-number-atom-collections', len(LambdasFoundinProtein) + 1)
        else:
            addParam('lambda-dynamics-number-lambda-group-types', len(LambdaTypeNamesFoundinProtein))
            addParam('lambda-dynamics-number-atom-collections', len(LambdasFoundinProtein))

        file.write('\n')

        # PART 2 - WRITE LAMBDA GROUP TYPES

        # Convert a list to a string
        def to_string(Input, round):
            string = ""
            for element in Input:
                string += "{0:.{arg}f} ".format(element, arg=round)
            return string

        # Writes the lambda group type block
        def writeLambdaGroupTypeBlock(number, name, multistates, qqA, qqB, pKa, dvdl):
            addParam('lambda-dynamics-group-type{}-name'.format(number), name)
            addParam('lambda-dynamics-group-type{}-n-states'.format(number), multistates)
            addParam('lambda-dynamics-group-type{}-state-0-charges'.format(number), to_string(qqA, 2))

            for idx in range(1, multistates + 1):
                # When we have a multistate lambdagrouptype, one of the pKas should 
                # be equal to the simulation-pH. This is done by setting this pKa 
                # to zero in the lambdagrouptypes.dat file.
                pKaNew = pKa[idx-1]
                if multistates > 1 and float(pKaNew) == 0.0:
                    pKaNew = self.ph_ph

                addParam('lambda-dynamics-group-type{}-state-{}-charges'.format(number, idx), to_string(qqB[idx-1], 2))
                addParam('lambda-dynamics-group-type{}-state-{}-reference-pka'.format(number, idx), pKaNew)
                addParam('lambda-dynamics-group-type{}-state-{}-dvdl-coefficients'.format(number, idx), to_string(dvdl[idx-1], 3))

            file.write('\n')

        number = 1
        # We loop over the object itself instead of the d_groupname as we need all
        # the information in the object.
        for LambdaType in self.ph_lambdaTypes:
            # This if-statement prevents writing a block when there are no residues 
            # of this type in the protein.
            if (LambdaType.d_groupname in LambdaTypeNamesFoundinProtein):

                writeLambdaGroupTypeBlock(
                    number,
                    LambdaType.d_groupname,
                    len(LambdaType.d_pKa),
                    LambdaType.d_qqA,
                    LambdaType.d_qqB,
                    LambdaType.d_pKa,
                    LambdaType.d_dvdl
                )

                number += 1

        # If we do charge restraining, we additionally need the block for the buffer.
        if restrainCharge:
            qqA = self.ph_BUF_range[0]
            qqB = self.ph_BUF_range[1]

            writeLambdaGroupTypeBlock(
                number,
                'BUF',
                1,
                [qqA],
                [[qqB]],
                [0],
                [self.ph_BUF_dvdl]
            )

        # PART 3 - WRITE LAMBDA GROUPS

        # GOAL : set the initial lambdas such that every titratable group and every
        # buffer has q = 0 at t = 0.

        # This function evaluates (the sums of) d_qqA and d_qqB and based on this
        # returns the initial values such that the titratable site is neutral.
        def determineLambdaInits(qqA, qqB):
            if len(qqB) > 1:    # We can ignore qqA in the multistate case. Instead
                inits = []      # we compile a list  of sums of the qqB states and 
                sums  = []      # set the state with the lowest abs val charge to 1
                for lst in qqB: # and the rest to 0.
                    sums.append(abs(sum(lst)))

                for idx in range(0, len(qqB)):
                    inits.append(idx == sums.index(min(sums)))

                return inits

            # In the 2state case, we simply pick the smallest abs val of the sum,
            # OR if the charges are opposite, the neutral charge will be in the
            # middle, which will then corresponds to lambda = 0.5.
            else:
                sumA = abs(sum(qqA))
                sumB = abs(sum(qqB[0]))

                if sumA == -sumB:
                    return [0.5]
                else:
                    return [float(sumA > sumB)]

        def writeResBlock(number, name, QQinitial, Edwp):
            addParam('lambda-dynamics-atom-set{}-name'.format(number), name)
            addParam('lambda-dynamics-atom-set{}-index-group-name'.format(number), 'LAMBDA{}'.format(number))
            addParam('lambda-dynamics-atom-set{}-initial-lambda'.format(number), to_string(QQinitial, 1))
            addParam('lambda-dynamics-atom-set{}-barrier'.format(number), Edwp)

            if restrainCharge:
                addParam('lambda-dynamics-atom-set{}-charge-restraint-group-index'.format(number), 1)

            if (name == 'BUF'):
                addParam('lambda-dynamics-atom-set{}-buffer-residue'.format(number), 'yes')
                addParam('lambda-dynamics-atom-set{}-buffer-residue-multiplier'.format(number), buffersFoundinProtein)

            file.write('\n')

        number = 1
        for residue in pdb.d_residues:
            if residue.d_resname in LambdaTypeNamesFoundinProtein:
                LambdaType = [obj for obj in self.ph_lambdaTypes if obj.d_groupname == residue.d_resname][0]
                QQinitial  = determineLambdaInits(LambdaType.d_qqA, LambdaType.d_qqB)

                # This interactive handler is OK for now.
                if self.ph_inter:
                    Edwp = input("phbuilder : set bias barrier (kJ/mol) for {}-{} in chain {} (or enter for default (= {})): ".format(residue.d_resname, residue.d_resid, residue.d_chain, self.ph_dwpE))
                    if Edwp == '':
                        Edwp = self.ph_dwpE
                    else:
                        Edwp = float(Edwp)
                        # print("Setting custom Edwp ({}) for residue {}-{} in chain {} (LAMBDA{})".format(Edwp, residue.d_resname, residue.d_resid, residue.d_chain, number))
                else:
                    Edwp = self.ph_dwpE

                writeResBlock(number, residue.d_resname, QQinitial, Edwp)

                number += 1

        if restrainCharge:
            BUFrange   = self.ph_BUF_range
            QQinitial  = determineLambdaInits([BUFrange[0]], [[BUFrange[1]]])
            writeResBlock(number, 'BUF', QQinitial, 0.0)

        file.close() # MD.mdp

        # PART 4 - WRITE LAMBBDA INDEX GROUPS

        # Append to existing index.ndx
        file = open('index.ndx', 'a')

        # Formatting function for writing the index block.
        def writeTheGroup(number, atomIndexList):
            file.write('\n[ LAMBDA{} ]\n'.format(number))
            for index in atomIndexList:
                file.write('{} '.format(index))
            file.write('\n')

        atomCount   = 1
        groupNumber = 1
        bufferIndexList = []

        # Write the lambda index groups for the titratable residues
        for residue in pdb.d_residues:
            # If the residue is titratable
            if residue.d_resname in LambdaTypeNamesFoundinProtein:
                # To hold the atom indices corresponding to the titratable atoms            
                atomIndexList = []
                # Corresponding LambdaType object
                LambdaType = [obj for obj in self.ph_lambdaTypes if obj.d_groupname == residue.d_resname][0]

                # Loop through atoms - note that the atoms need to be descending order
                for atom in residue.d_atoms:
                    if atom in LambdaType.d_atoms:
                        atomIndexList.append(atomCount)

                    atomCount += 1

                # Write the lambda index group and increment groupnumber
                writeTheGroup(groupNumber, atomIndexList)
                groupNumber += 1

            elif restrainCharge and residue.d_resname == 'BUF':
                bufferIndexList.append(atomCount)
                atomCount += 1

            else: # Increment atomCount
                for atom in residue.d_atoms:
                    atomCount += 1

        # If we do charge restraining write the lambda index group for the buffer(s)
        if restrainCharge:
            writeTheGroup(groupNumber, bufferIndexList)

        file.close() # index.ndx

    # Handle user input.
    def inputOptionHandler(self, message, options):

        valids = []
        msgstring = "phbuilder : {}:".format(message)

        # Loop through the options list and create string for dislay
        for idx in range(0, len(options)):
            msgstring += "\nphbuilder : {}. {}".format(idx, options[idx])
            valids.append(str(idx))

        while True:
            print(msgstring)
            val = input("phbuilder : Type a number: ")

            if val in valids:
                print()
                return int(val)

            print("phbuilder : {} is not a valid option, please try again:\n".format(val))

phbuilder(CLI).runner()

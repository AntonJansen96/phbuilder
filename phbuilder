#!/bin/python3
# PYTHON_ARGCOMPLETE_OK

# Execute this as soon as possible because of the TAB autocomplete thing.
from parsecmdline import parsecmdline
CLI = parsecmdline()

# Import the rest of the modules.
import configparser, os
from structure import Structure
from mdp import gen_mdp

# Stores the information for a lambda group type.
class LambdaType:
    def __init__(self, groupname, incl, pKa, atoms, qqA, qqB, dvdl):
        self.d_groupname = groupname  # str
        self.d_incl      = incl       # list
        self.d_pKa       = pKa        # list  (previously str)
        self.d_atoms     = atoms      # list
        self.d_qqA       = qqA        # list
        self.d_qqB       = qqB        # list of lists (previously list)
        self.d_dvdl      = dvdl       # list of lists (previously list)

# Main phbuilder object.
class phbuilder(Structure):
    # Construct phbuilder object (handles input parsed from cmdline).
    def __init__(self, CLI):
        # Add universal parameters to the universe (used by all three targets).
        self.d_target    = CLI.target
        self.d_verbosity = CLI.verbosity

        # If we run gentopol...
        if (CLI.target == 'gentopol'):
            self.d_file   = CLI.file
            self.d_output = CLI.output

            # Process whether the -inter flag was or wasn't set.
            if (CLI.inter != None):
                self.ph_inter = True
            else:
                self.ph_inter = False

            # Process whether the -list flag was or wasn't set.
            if (CLI.list != None):
                resid = []
                for line in open(CLI.list).readlines():
                    resid.append(line.split()[0])

                self.ph_list_resid = [int(i) for i in resid]

        # If we run addbuffers...
        elif (CLI.target == 'addbuffers'):
            # Either required or has a default value
            self.d_file    = CLI.file
            self.d_output  = CLI.output
            self.d_topol   = CLI.topol
            self.d_solname = CLI.solname

            # Optional
            if (CLI.nbufs != None):
                self.ph_nbufs = CLI.nbufs

        # If we run genparams...
        elif (CLI.target == 'genparams'):
            self.d_file    = CLI.file
            self.d_mdp     = CLI.mdp
            self.d_ndx     = CLI.ndx
            self.ph_ph     = CLI.ph
            self.ph_nstout = CLI.nstout
            self.ph_dwpE   = CLI.dwpE
            self.ph_lmass  = CLI.lmass
            self.ph_ltau   = CLI.ltau

            # Process whether the -inter flag was or wasn't set
            if (CLI.inter != None):
                self.ph_inter = True
            else:
                self.ph_inter = False

        # User information.
        self.update("Parsed the following input from the command line:")
        self.update(vars(CLI))

        self.parseLambdaGroupTypesFile()

    # Parse lambdagrouptypes.dat
    def parseLambdaGroupTypesFile(self):
        # Initialize some entries
        self.ph_lambdaTypes = []
        self.ph_BUF_dvdl    = None

        # Add a lambda residue-type to universe.
        def defineLambdaType(groupname, incl, pKa, atoms, qqA, qqB, dvdl):

            # Create a temporary LambdaType object.
            NewLambdaType = LambdaType(groupname, incl, pKa, atoms, qqA, qqB, dvdl)

            # Only add NewLambdaType to ph_lambdaTypes if it does not exist yet.
            alreadyPresent = False
            for entry in self.ph_lambdaTypes:
                if entry.d_groupname == NewLambdaType.d_groupname:
                    self.update("LambdaType with groupname {} is already defined. Skipping...")
                    alreadyPresent = True
                    break

            if not alreadyPresent:
                self.ph_lambdaTypes.append(NewLambdaType)

        # Internal function to convert string to list of floats.
        def str2floatList(string):
            return [float(val) for val in string.split(' ')]

        # Internal function to convert string to list of strings.
        def str2strList(string):
            return string.split(' ')

        parser = configparser.ConfigParser()
        parser.read("lambdagrouptypes.dat") # name is hardcoded.

        # Loop through the sections.
        for sect in parser.sections():

            if (sect.strip() == "FORCEFIELD"):
                self.d_modelFF    = parser.get(sect, 'path')
                self.d_modelwater = parser.get(sect, 'water')
                continue

            if (sect.strip() == "BUF"):
                self.ph_BUF_dvdl  = str2floatList(parser.get(sect, 'dvdl'))
                self.ph_BUF_range = str2floatList(parser.get(sect, 'range'))
                continue

            # Parse groupname
            groupname = sect.strip()[0:4]

            # Parse incl
            incl = str2strList(parser.get(sect, 'incl'))

            # Parse atoms
            atoms = str2strList(parser.get(sect, 'atoms'))

            # Parse qqA
            qqA = str2floatList(parser.get(sect, 'qqA'))

            pKa  = []
            qqB  = []
            dvdl = []
            for idx in range(1, 11): # Max 10 multistates
                try:
                    # Parse pKa(s)
                    pKa.append(parser.get(sect, 'pKA_{}'.format(idx)))

                    # Parse qqB(s)
                    qqB.append(str2floatList(parser.get(sect, 'qqB_{}'.format(idx))))

                    # Parse dvdl(s)
                    dvdl.append(str2floatList(parser.get(sect, 'dvdl_{}'.format(idx))))
                except:
                    break

            # SANITIZE INPUT

            if (len(groupname) < 2 or len(groupname) > 4):
                self.error("groupname of LambdaType needs to contain between 2 and 4 characters.")

            # Call function that constructs the LambdaType object.
            defineLambdaType(groupname, incl, pKa, atoms, qqA, qqB, dvdl)

        # USER UPDATE

        self.update("ffpath    = {}".format(self.d_modelFF))
        self.update("water     = {}".format(self.d_modelwater))

        for obj in self.ph_lambdaTypes:
            self.update("groupname = {}".format(obj.d_groupname))
            self.update("incl      = {}".format(obj.d_incl))
            self.update("pKa       = {}".format(obj.d_pKa))
            self.update("atoms     = {}".format(obj.d_atoms))
            self.update("qqA       = {}".format(obj.d_qqA))
            self.update("qqB       = {}".format(obj.d_qqB))
            self.update("dvdl      = {}\n".format(obj.d_dvdl))

        if (self.ph_BUF_dvdl != None):
            self.update("BUF_dvdl  = {}\n".format(self.ph_BUF_dvdl))
        else:
            self.update("dvdl coefficients for buffer were not found in lambdagrouptypes.dat.")
            self.update("This is fine if you don't plan on using charge restraining/buffers.")

    # Call correct sub function depending on specified target on cmdline.
    def runner(self):
        if self.d_target == 'gentopol':
            self.update('Running gentopol...')
            self.gentopol()

        elif self.d_target == 'addbuffers':
            self.update('Running addbuffers...')
            self.addbuffers()

        elif self.d_target == 'genparams':
            self.update('Running genparams...')
            self.genparams()

    # Prepare topology.
    def gentopol(self):
        # Part I - COPY FORCE FIELD AND RESIDUETYPES.DAT TO WORKING DIR

        tail, head = os.path.split(self.d_modelFF)

        os.system("cp -r {} {}/residuetypes.dat .".format(self.d_modelFF, tail))

        self.update('Force field path stuff: ')
        self.update('full-path    = {}'.format(self.d_modelFF))
        self.update('tail-path    = {}'.format(tail))
        self.update('residuetypes = {}/residuetypes.dat'.format(tail))
        self.update('head-path    = {}'.format(head))

        self.d_modelFF = head[0:len(head)-3]
        self.update('ffield name  = {}'.format(self.d_modelFF))

        # PART I - MODIFIY THE STRUCTURE FILE AND WRITE

        self.update("Modifying structure file...")

        # Load the structure.
        pdb = Structure(self.d_file)

        # List of titratable names, e.g. [ASPT, GLUT].
        lambdaTypeNames = [] 

        # List of lists of all the incl names for the LambdaTypes,
        # e.g. [[ASP1, ASPH, ASPP, ASH], [GLU, GLUH, GLUP]].
        residuesToBeConsidered = []

        for lambdaType in self.ph_lambdaTypes:
            lambdaTypeNames.append(lambdaType.d_groupname)
            residuesToBeConsidered.append(lambdaType.d_incl)

        # Checks whether the resname is in any of the lists of targets.
        # If found, return index of said list. If not found, return None.
        def isTarget(resname):
            for idx in range(0, len(residuesToBeConsidered)):
                if resname in residuesToBeConsidered[idx]:
                    return idx
            return None

        # If a list of specific residues was specified, load it.
        if hasattr(self, 'ph_list_resid'):
            list_resid = self.ph_list_resid

            # User udate
            self.update('Found user-defined list of which residues to consider:')
            self.update(list_resid)

        # Loop through the residue objects.
        for residue in pdb.d_residues:

            # This will either be None if the residue does not have to be considered 
            # (i.e. it doesn't belong to any incl group), or it will have the index of 
            # the incl grou it belongs to.
            index = isTarget(residue.d_resname)

            # If we find a residue that was specified to be titratable...
            if (index != None):

                # Original name of the residue before we change it. We store this
                # here because we'll need it later for a user update.
                origName = residue.d_resname

                # If -list was set AND the current resid is not in list, continue to next residue in loop above.
                if hasattr(self, 'ph_list_resid') and (residue.d_resid not in list_resid):
                    continue

                # If -inter was set, ask for every residue individually:
                if self.ph_inter:

                    # Handle the user input
                    takeInput = True

                    while (takeInput):

                        val = input("phbuilder : Choose what to do with residue {}-{} in chain {}:\nphbuilder : 0. Keep current (static) protonation state\nphbuilder : 1. Make titratable (change name to {})\nphbuilder : Type a number: ".format(
                            residue.d_resname,
                            residue.d_resid,
                            residue.d_chain,
                            lambdaTypeNames[index]))

                        if (val == '0'):
                            takeInput = False

                        elif (val == '1'):
                            residue.d_resname = lambdaTypeNames[index]
                            takeInput = False

                        else:
                            print("{} is not a valid option, please try again:".format(val))

                        print()
                    # End of input handling

                else: # If -inter was not set, just protonate everything automatically.
                    residue.d_resname = lambdaTypeNames[index]
                    self.update("Made residue {}-{} in chain {} titratable (changed name to {})".format(origName, residue.d_resid, residue.d_chain, residue.d_resname))

                continue # Otherwise code below is executed for the same residue we just changed.

            # Again loop through the residue objects, but now we look for ones that were already changed.
            if (residue.d_resname in lambdaTypeNames):

                # If -list was set AND the current resid is not in list, continue to next residue in loop.
                if hasattr(self, 'ph_list_resid') and (residue.d_resid not in list_resid):
                    continue

                # If -inter was set, ask for every residue individually:
                if self.ph_inter:

                    # Handle the user input
                    takeInput = True

                    while (takeInput):

                        # Some user updates:
                        self.update("Choose what to do with residue {}-{} in chain {}:".format(residue.d_resname, residue.d_resid, residue.d_chain))
                        self.update("0. Keep titratable (do not change name)")

                        for idx in range(0, len(residuesToBeConsidered[lambdaTypeNames.index(residue.d_resname)])):
                            self.update("{}. change name to {} (no longer titratable)".format(idx + 1, residuesToBeConsidered[lambdaTypeNames.index(residue.d_resname)][idx]))

                        val = eval(input("Type a number: "))

                        # Handle incorrect input:
                        if (type(val) != int or val not in range(0, len(residuesToBeConsidered[lambdaTypeNames.index(residue.d_resname)]))):
                            self.update("{} is not a valid option, please try again:\n".format(val))
                            continue
                        else:
                            takeInput = False

                        # Process the specified option:
                        if (val == 0):
                            continue
                        else:
                            residue.d_resname = residuesToBeConsidered[lambdaTypeNames.index(residue.d_resname)][val-1]

                        print()
                    # End of input handling

        # Write structure.
        pdb.write(self.d_output)

        # PART III - HANDLE UNKNOWN STRUCTURE TYPES

        self.update("Checking if every residue type is present in residuetypes.dat...")

        # Load residuetypes.dat into list
        residueTypes = []
        for val in open('residuetypes.dat').readlines():
            residueTypes.append(val.split()[0])

        # Compile lists of the unknown residue(s)(types)
        unknownResidues = []
        unknownResTypeNames = []
        for residue in pdb.d_residues:
            
            if residue.d_resname not in residueTypes:
                unknownResidues.append(residue)

                if residue.d_resname not in unknownResTypeNames:
                    unknownResTypeNames.append(residue.d_resname)

        pathList = []   # Loop through the unknown residue types and add them to 
        skipList = []   # skipList and (the manually specified path to) pathList.
        good = True
        for val in unknownResTypeNames:
            self.update("WARNING - residue type {} in {} wasn't found in residuetypes.dat associated with {}".format(val, self.d_file, self.d_modelFF))
            path = input("phbuilder : Please specify path to .itp file (e.g. /path/to/some.itp): ")

            skipList.append(val)
            pathList.append(path)
            good = False

            self.update("Set path for residue type {} to {}...".format(val, path))

        if good:
            self.update("everything seems OK.")

        # If pathList is not empty, i.e. if we had at least one unknown residue
        if pathList:

            # Create a list knownResidues containing only the known residues
            knownResidues = []
            for residue in pdb.d_residues:
                if residue.d_resname not in skipList:
                    knownResidues.append(residue)

            # Update d_residues in universe with knownResidues
            pdb.d_residues = knownResidues

            # Write temporary .pdb containing only the known residues
            someTempName = 'pdb2gmxtemp.pdb'
            pdb.write(someTempName)

            # Update value of d_output (so that pdb2gmx is called on the temporary 
            # structure), and backup the final output name as specified by user.
            self.d_output_orig = self.d_output
            self.d_output      = someTempName

        # PART IV - RUN PDB2GMX AND ASK USER FOR INPUT ABOUT IT 

        self.update("\nRecommended pdb2gmx command:")
        self.update("gmx pdb2gmx -f {0} -o {0} -ff {1} -water {2} -ignh".format(self.d_output, self.d_modelFF, self.d_modelwater))

        takeInput = True
        while (takeInput):

            # Prompt user for input:
            val = input("phbuilder : Choose whether to:\nphbuilder : 0. Do nothing\nphbuilder : 1. Run\nphbuilder : 2. Add additional flags (https://manual.gromacs.org/documentation/current/onlinehelp/gmx-pdb2gmx.html)\nphbuilder : Type a number: ")

            # Handle incorrect input:
            if val not in ['0', '1', '2']:
                self.update("{} is not a valid option, please try again:\n".format(val))
                continue
            else:
                takeInput = False

            # Take additional flags:
            if (val == '2'):
                flags = input("phbuilder : Enter flags: ")
            else:
                flags = ''

            # Run pdb2gmx:
            if (val in ['1', '2']):
                self.update("Calling GROMACS ({}/gmx)...\n".format(os.environ.get("GMXBIN")))
                os.system("gmx pdb2gmx -f {0} -o {0} -ff {1} -water {2} -ignh {3}".format(self.d_output, self.d_modelFF, self.d_modelwater, flags))
            if (val == '0'):
                return

        # PART V - MERGE THE .PDB FILES

        # If pathList is not empty, i.e. if we had at least one unknown residue:
        if pathList:
            # Load the structure output of pdb2gmx (update d_residues in universe)
            pdb = Structure(someTempName)

            # Merge the processed structure of good residues with unknown residues
            mergedResidues = pdb.d_residues + unknownResidues

            # Update d_residues in universe
            pdb.d_residues = mergedResidues

            # Write the final structure
            pdb.write(self.d_output_orig)

        # PART VI - MERGE THE TOPOLOGIES

        # Write manually specified files to topol.top
        def add_mol(itpfname, comment, molname=None, molcount=None):
            # Get the contents of current topol.top.
            topList = []
            with open("topol.top") as file:
                for line in file.readlines():
                    topList.append(line)

            # Add the .itp file (line saying: #include "blabla.itp")
            with open("topol.top", 'w') as file:
                try:
                    for line in range(0, len(topList)):
                        file.write(topList[line])

                        if "[ system ]\n" == topList[line + 1]:
                            file.write("; {0}\n".format(comment))
                            file.write("#include \"{0}\"\n\n".format(itpfname))

                except IndexError:
                    pass

            # if molcount not present, add it, otherwise do nothing.
                if molname != None and molcount != None and molname not in topList[-1]:
                    file.write("{0}\t\t\t{1}\n".format(molname, molcount))

        # If pathList is not empty, i.e. if we had at least one unknown residue:
        if pathList:
            # Remove temporary .pdb file
            os.remove(someTempName)

            # Loop through the unknown residue types
            for idx in range(0, len(skipList)):

                # For each one, count how many there are
                count = 0
                for residue in pdb.d_residues:
                    if residue.d_resname == skipList[idx]:
                        count += 1

                # Add manually to topol.top
                add_mol(pathList[idx], "Include topology for {}".format(skipList[idx]), skipList[idx], count)

        self.update("Finished generating topology for constant-pH.")

    # Add buffers.
    def addbuffers(self):
        maxChargeOnBuffer = 0.3

        # PART I - PREP

        # Load the input structure into d_residues.
        pdb = Structure(self.d_file)

        # Perform some basic checks for PBC box, solvent, and titratable groups.
        foundPBC         = hasattr(pdb, 'd_box')
        foundSolvent     = False
        foundTitratables = False

        LambdaTypeNames = []
        for LambdaType in self.ph_lambdaTypes:
            LambdaTypeNames.append(LambdaType.d_groupname)

        for residue in pdb.d_residues:

            if residue.d_resname == self.d_solname:
                foundSolvent = True

            elif residue.d_resname in LambdaTypeNames:
                foundTitratables = True

            if foundSolvent and foundTitratables:
                break

        # Error if no periodic box was found
        if not foundPBC:
            self.error("{} doesn't have a periodic box! Did you forget to add one?".format(self.d_file))

        # Error if no solvent was found
        if not foundSolvent:
            self.error("{} doesn't seem to have any {} molecules! Did you forget to add solvent?".format(self.d_file, self.d_solname))

        # Error if no titratable residues were found
        if not foundTitratables:
            self.update("WARNING - {} doesn't seem to have any titratable groups! Did you forget to run gentopol?".format(self.d_file))

        # if nbufs wasn't manually set, count the number of titratable residues.
        if not hasattr(self, 'ph_nbufs'):
            # Count number of titratable residues
            titratables = 0
            for residue in pdb.d_residues:
                if residue.d_resname in LambdaTypeNames:
                    titratables += 1

            nbufs = int(titratables / maxChargeOnBuffer) + 1 # Worst case scenario.
            self.update("Counted {0} titratable residues, will add ceil({0}/{1}) = {2} buffer(s)...".format(titratables, maxChargeOnBuffer, nbufs))

        else:
            nbufs = self.ph_nbufs
            self.update("Will add {} buffer(s) (per user request)...".format(nbufs))

        # PART II - RUN GMX GENION TO REPLACE SOLVENT MOLECULES WITH BUFFER

        # Create dummy mdp file for gmx grompp
        open('dummy.mdp', 'w').close()

        # Run gmx grompp to create a .tpr file for gmx genion
        os.system("gmx grompp -f dummy.mdp -c {} -p {} -o dummy.tpr >> builder.log 2>&1".format(self.d_file, self.d_topol))

        # Run gxm genion to replace some solvent molecules with buffers
        os.system("gmx genion -s dummy.tpr -p {} -o {} -pname {} -np {} >> builder.log 2>&1 << EOF\n{}\nEOF".format(
            self.d_topol,
            self.d_output,
            'BUF', 
            self.ph_nbufs,
            self.d_solname))

        # PART III - WRAPUP

        # Remove dummy files
        os.remove('dummy.tpr'); os.remove('dummy.mdp')

        # Update d_residues in universe
        pdb = Structure(self.d_output)

        # Check whether the required number of buffers was added
        BUFcount = 0
        for residue in pdb.d_residues:
            if residue.d_resname == 'BUF':
                BUFcount += 1

        if BUFcount == nbufs:
            self.update("Succesfully added {} buffer molecule(s)...".format(BUFcount))
        else:
            self.update("Only added {}/{} buffer molecules! Try increasing box size...")

    # Generate parameters for MD.mdp.
    def genparams(self):
        # PART I - PREP

        # Load the input structure into d_residues.
        pdb = Structure(self.d_file)

        # List of groupnames of the LambdaTypes specified in lambdagrouptypes.dat.
        LambdaTypeNames = []
        for LambdaType in self.ph_lambdaTypes:
            LambdaTypeNames.append(LambdaType.d_groupname)

        # Check whether we have any titratable residues in the structure, and also
        # check whether we have any buffers.
        anyTitratables = False
        restrainCharge = False

        for residue in pdb.d_residues:
            if residue.d_resname in LambdaTypeNames:
                anyTitratables = True

            elif residue.d_resname == 'BUF':
                restrainCharge = True

            if anyTitratables and restrainCharge:
                break

        if not anyTitratables:
            self.error("No titratable residues detected!")

        if not restrainCharge:
            self.update("No buffer(s) found. Will not use charge restraining...")

        # If no .mdp file was specified on the command line, generate our default one:
        if self.d_mdp == None:
            self.update('No .mdp file was specified. Creating a default MD.mdp file...')

            val = input("phbuilder : simulating a membrane protein?\n0 no\n1 yes\n")
            if val == '0':
                gen_mdp('MD', 50000, 5000, membrane=False)
            elif val == '1':
                gen_mdp('MD', 50000, 5000, membrane=True)

            self.d_mdp = 'MD.mdp'

        # If no .ndx file was specified on the command line, generate our default one:
        if self.d_ndx == None:
            self.update('No .ndx file was specified. Creating a default index.ndx file...')
            os.system("gmx make_ndx -f {0} >> builder.log 2>&1 << EOF\nq\nEOF".format(self.d_file))

        file = open(self.d_mdp, 'a')

        # Formatting function for adding parameters.
        def addParam(name, value):
                file.write("{:54s} = {:13s}\n".format(name, str(value)))

        # PART 1 - WRITE GENERAL PARAMETERS

        file.write("\n; CONSTANT PH\n")

        addParam('lambda-dynamics', 'yes')
        addParam('lambda-dynamics-simulation-ph', "{:.1f}".format(self.ph_ph))
        addParam('lambda-dynamics-lambda-particle-mass', "{:.1f}".format(self.ph_lmass))
        addParam('lambda-dynamics-tau', "{:.1f}".format(self.ph_ltau))
        addParam('lambda-dynamics-update-nst', self.ph_nstout)

        # If we use charge restraining...
        if restrainCharge:
            addParam('lambda-dynamics-charge-constraints', 'yes')

        # We need to count how many titratable residues in total we have in the
        # protein. For this we compile a list LambdasFoundinProtein.
        LambdasFoundinProtein = [] # (e.g ASPT ASPT GLUT ASPT GLUT ASPT...)

        # Stores the number of buffer atoms/ions.
        buffersFoundinProtein = 0

        for residue in pdb.d_residues:
            if residue.d_resname in LambdaTypeNames:
                LambdasFoundinProtein.append(residue.d_resname)

            # Also in this loop we count how many buffer ions we have.
            elif restrainCharge and residue.d_resname == 'BUF':
                buffersFoundinProtein += 1

        # The fact that we have a LambdaType in lambdagrouptypes.dat does not mean
        # one of those is also present in the protein. In that case, we want to 
        # prevent counting it, so we compile a subgroup of LambdaType groupnames
        # that are not only in lambdagrouptypes.dat, but ALSO found at least once 
        # in the actual protein.
        LambdaTypeNamesFoundinProtein = list(set(LambdasFoundinProtein)) # (e.g ASPT GLUT)

        # If we not only have multistate LambdaResidueTypes defined in the .dat file,
        # but we also have detected such a LambdaResidueType in the actual protein,
        # we'll need to turn on multistate:
        for LambdaType in self.ph_lambdaTypes:
            if len(LambdaType.d_pKa) > 1 and LambdaType.d_groupname in LambdaTypeNamesFoundinProtein:
                addParam('lambda-dynamics-multistate-constraints', 'yes')

        # If we use charge-restraining we also have he BUF residue-type, as well as 
        # one extra lambda group containing all the BUFs.
        if restrainCharge:
            addParam('lambda-dynamics-number-lambda-group-types', len(LambdaTypeNamesFoundinProtein) + 1)
            addParam('lambda-dynamics-number-atom-collections', len(LambdasFoundinProtein) + 1)
        else:
            addParam('lambda-dynamics-number-lambda-group-types', len(LambdaTypeNamesFoundinProtein))
            addParam('lambda-dynamics-number-atom-collections', len(LambdasFoundinProtein))

        file.write('\n')

        # PART 2 - WRITE LAMBDA GROUP TYPES

        # Convert a list to a string
        def to_string(Input, round):
            string = ""
            for element in Input:
                string += "{0:.{arg}f} ".format(element, arg=round)
            return string

        # Writes the lambda group type block
        def writeLambdaGroupTypeBlock(number, name, multistates, qqA, qqB, pKa, dvdl):
            addParam('lambda-dynamics-group-type{}-name'.format(number), name)
            addParam('lambda-dynamics-group-type{}-n-states'.format(number), multistates)
            addParam('lambda-dynamics-group-type{}-state-0-charges'.format(number), to_string(qqA, 2))

            for idx in range(1, multistates + 1):
                # When we have a multistate lambdagrouptype, one of the pKas should 
                # be equal to the simulation-pH. This is done by setting this pKa 
                # to zero in the lambdagrouptypes.dat file.
                pKaNew = pKa[idx-1]
                if multistates > 1 and float(pKaNew) == 0.0:
                    pKaNew = self.ph_ph

                addParam('lambda-dynamics-group-type{}-state-{}-charges'.format(number, idx), to_string(qqB[idx-1], 2))
                addParam('lambda-dynamics-group-type{}-state-{}-reference-pka'.format(number, idx), pKaNew)
                addParam('lambda-dynamics-group-type{}-state-{}-dvdl-coefficients'.format(number, idx), to_string(dvdl[idx-1], 3))

            file.write('\n')

        number = 1
        # We loop over the object itself instead of the d_groupname as we need all
        # the information in the object.
        for LambdaType in self.ph_lambdaTypes:
            # This if-statement prevents writing a block when there are no residues 
            # of this type in the protein.
            if (LambdaType.d_groupname in LambdaTypeNamesFoundinProtein):

                writeLambdaGroupTypeBlock(
                    number,
                    LambdaType.d_groupname,
                    len(LambdaType.d_pKa),
                    LambdaType.d_qqA,
                    LambdaType.d_qqB,
                    LambdaType.d_pKa,
                    LambdaType.d_dvdl
                )

                number += 1

        # If we do charge restraining, we additionally need the block for the buffer.
        if restrainCharge:
            qqA = self.ph_BUF_range[0]
            qqB = self.ph_BUF_range[1]

            writeLambdaGroupTypeBlock(
                number,
                'BUF',
                1,
                [qqA],
                [[qqB]],
                [0],
                [self.ph_BUF_dvdl]
            )

        # PART 3 - WRITE LAMBDA GROUPS

        # GOAL : set the initial lambdas such that every titratable group and every
        # buffer has q = 0 at t = 0.

        # This function evaluates (the sums of) d_qqA and d_qqB and based on this
        # returns the initial values such that the titratable site is neutral.
        def determineLambdaInits(qqA, qqB):
            if len(qqB) > 1:    # We can ignore qqA in the multistate case. Instead
                inits = []      # we compile a list  of sums of the qqB states and 
                sums  = []      # set the state with the lowest abs val charge to 1
                for lst in qqB: # and the rest to 0.
                    sums.append(abs(sum(lst)))

                for idx in range(0, len(qqB)):
                    inits.append(idx == sums.index(min(sums)))

                return inits

            # In the 2state case, we simply pick the smallest abs val of the sum,
            # OR if the charges are opposite, the neutral charge will be in the
            # middle, which will then corresponds to lambda = 0.5.
            else:
                sumA = abs(sum(qqA))
                sumB = abs(sum(qqB[0]))

                if sumA == -sumB:
                    return [0.5]
                else:
                    return [float(sumA > sumB)]

        def writeResBlock(number, name, QQinitial, Edwp):
            addParam('lambda-dynamics-atom-set{}-name'.format(number), name)
            addParam('lambda-dynamics-atom-set{}-index-group-name'.format(number), 'LAMBDA{}'.format(number))
            addParam('lambda-dynamics-atom-set{}-initial-lambda'.format(number), to_string(QQinitial, 1))
            addParam('lambda-dynamics-atom-set{}-barrier'.format(number), Edwp)

            if restrainCharge:
                addParam('lambda-dynamics-atom-set{}-charge-restraint-group-index'.format(number), 1)

            if (name == 'BUF'):
                addParam('lambda-dynamics-atom-set{}-buffer-residue'.format(number), 'yes')
                addParam('lambda-dynamics-atom-set{}-buffer-residue-multiplier'.format(number), buffersFoundinProtein)

            file.write('\n')

        number = 1
        for residue in pdb.d_residues:
            if residue.d_resname in LambdaTypeNamesFoundinProtein:
                LambdaType = [obj for obj in self.ph_lambdaTypes if obj.d_groupname == residue.d_resname][0]
                QQinitial  = determineLambdaInits(LambdaType.d_qqA, LambdaType.d_qqB)

                # This interactive handler is OK for now.
                if self.ph_inter:
                    Edwp = input("phbuilder : set bias barrier (kJ/mol) for {}-{} in chain {} (or enter for default (= {})): ".format(residue.d_resname, residue.d_resid, residue.d_chain, self.ph_dwpE))
                    if Edwp == '':
                        Edwp = self.ph_dwpE
                    else:
                        Edwp = float(Edwp)
                        # print("Setting custom Edwp ({}) for residue {}-{} in chain {} (LAMBDA{})".format(Edwp, residue.d_resname, residue.d_resid, residue.d_chain, number))
                else:
                    Edwp = self.ph_dwpE

                writeResBlock(number, residue.d_resname, QQinitial, Edwp)

                number += 1

        if restrainCharge:
            BUFrange   = self.ph_BUF_range
            QQinitial  = determineLambdaInits([BUFrange[0]], [[BUFrange[1]]])
            writeResBlock(number, 'BUF', QQinitial, 0.0)

        file.close() # MD.mdp

        # PART 4 - WRITE LAMBBDA INDEX GROUPS

        # Append to existing index.ndx
        file = open('index.ndx', 'a')

        # Formatting function for writing the index block.
        def writeTheGroup(number, atomIndexList):
            file.write('\n[ LAMBDA{} ]\n'.format(number))
            for index in atomIndexList:
                file.write('{} '.format(index))
            file.write('\n')

        atomCount   = 1
        groupNumber = 1
        bufferIndexList = []

        # Write the lambda index groups for the titratable residues
        for residue in pdb.d_residues:
            # If the residue is titratable
            if residue.d_resname in LambdaTypeNamesFoundinProtein:
                # To hold the atom indices corresponding to the titratable atoms            
                atomIndexList = []
                # Corresponding LambdaType object
                LambdaType = [obj for obj in self.ph_lambdaTypes if obj.d_groupname == residue.d_resname][0]

                # Loop through atoms - note that the atoms need to be descending order
                for atom in residue.d_atoms:
                    if atom in LambdaType.d_atoms:
                        atomIndexList.append(atomCount)

                    atomCount += 1

                # Write the lambda index group and increment groupnumber
                writeTheGroup(groupNumber, atomIndexList)
                groupNumber += 1

            elif restrainCharge and residue.d_resname == 'BUF':
                bufferIndexList.append(atomCount)
                atomCount += 1

            else: # Increment atomCount
                for atom in residue.d_atoms:
                    atomCount += 1

        # If we do charge restraining write the lambda index group for the buffer(s)
        if restrainCharge:
            writeTheGroup(groupNumber, bufferIndexList)

        file.close() # index.ndx

    # Provides updates of various verbosity for the user.
    def update(self, message, verbosity=2):
        # If specified verbosity is larger than verbosity set for the specific message, print.
        if self.d_verbosity >= verbosity:

            # Formatting for if we want to print a list.
            if type(message) == type([]) or type(message) == type({}):

                print("phbuilder : ", end='')
                print(message)

            # Formatting for if we want a newline at the start.
            elif message[0] == '\n':
                print("\nphbuilder : {}".format(message[1:]))

            else:
                print("phbuilder : {}".format(message))

    # Prints error message for the user and quits program.
    def error(self, message, verbosity=2):

        if self.d_verbosity >= verbosity:

            print("phbuilder : ERROR - {} quiting...".format(message))

        quit()

phbuilder(CLI).runner()
